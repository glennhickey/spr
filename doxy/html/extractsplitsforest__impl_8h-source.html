<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SPR: extractsplitsforest_impl.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>extractsplitsforest_impl.h</h1><a href="extractsplitsforest__impl_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#include &lt;set&gt;</span>
00002 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00003 <span class="preprocessor">#include &lt;limits&gt;</span>
00004 
00005 <a class="code" href="classSplit.html#a0">Split::Split</a>() : std::vector&lt;std::string&gt;(), _left(-1), _right(-1)
00006 {
00007 }
00008 
00009 <a class="code" href="classSplit.html#a0">Split::Split</a>(size_t size) : std::vector&lt;std::string&gt;(size), 
00010                                   _left(-1), _right(-1)
00011 {
00012 }
00013 
00014 <span class="keywordtype">bool</span> <a class="code" href="classSplit.html#a2">Split::operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classSplit.html">Split</a>&amp; split)<span class="keyword"> const</span>
00015 <span class="keyword"></span>{
00016   <span class="keywordflow">if</span> (_rp &lt; split._rp)
00017     return true;
00018   if (_rp &gt; split._rp)
00019     return false;
00020   for (size_t i = 0; i &lt; _rp; ++i)
00021   {
00022     <span class="keywordflow">if</span> (this-&gt;at(i) &lt; split.at(i))
00023       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00024     <span class="keywordflow">if</span> (this-&gt;at(i) &gt; split.at(i))
00025       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00026   }
00027   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00028 }
00029 
00030 <span class="keywordtype">bool</span> <a class="code" href="structSplitPLess.html#a0">SplitPLess::operator()</a>(<a class="code" href="classSplit.html">Split</a>* s1, <a class="code" href="classSplit.html">Split</a>* s2)
00031 {
00032   <span class="keywordflow">return</span> *s1 &lt; *s2;
00033 }
00034 
00035 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00036"></a><a class="code" href="extractsplitsforest__impl_8h.html#a0">00036</a> std::ostream&amp; <a class="code" href="extractsplitsforest_8cpp.html#a0">operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> <a class="code" href="classSplit.html">Split</a>&amp; split)
00037 {
00038   size_t i = 0;
00039   <span class="keywordflow">for</span> (; i &lt; split._rp; ++i)
00040     os &lt;&lt; (int)split[i]  &lt;&lt; <span class="charliteral">' '</span>;
00041   os &lt;&lt; <span class="stringliteral">" /"</span>;
00042   <span class="keywordflow">for</span> (; i &lt; split.size(); ++i)
00043     os &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; (int)split[i];
00044   
00045   <span class="keywordflow">return</span> os;
00046 }
00047 
00048 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00049 <a class="code" href="classExtractSplitsForest.html#a0">ExtractSplitsForest&lt;T&gt;::ExtractSplitsForest</a>()
00050 {
00051 }
00052 
00056 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00057 <span class="keywordtype">int</span> <a class="code" href="classExtractSplitsForest.html#a2">ExtractSplitsForest&lt;T&gt;::extract</a>(<span class="keyword">const</span> <a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>&amp; t1, <span class="keyword">const</span> <a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>&amp; t2, 
00058                                     std::vector&lt;std::string&gt;&amp; f1, 
00059                                     std::vector&lt;std::string&gt;&amp; f2)
00060 {
00061   <span class="comment">// first convert trees to arrays</span>
00062   std::vector&lt;std::string&gt; tree1, tree2;
00063   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; t1.size(); ++i)
00064   {
00065     std::stringstream ss1, ss2;
00066     ss1 &lt;&lt; t1[i];
00067     tree1.push_back(ss1.str());
00068     ss2 &lt;&lt; t2[i];
00069     tree2.push_back(ss2.str());
00070   }
00071 
00072   <span class="comment">// make forest out of non-trivial common splits</span>
00073   std::vector&lt;std::vector&lt;std::string&gt; &gt; input1, input2;
00074   std::vector&lt;std::vector&lt;std::string&gt; &gt; output1, output2;
00075   input1.push_back(tree1);
00076   input2.push_back(tree2);
00077   
00078   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; input1.size(); ++i)
00079   {
00080     std::vector&lt;std::string&gt; sub1a, sub1b, sub2a, sub2b;
00081     <span class="keywordflow">if</span> (breakLCS(input1[i], input2[i], sub1a, sub1b, sub2a, sub2b) == <span class="keyword">true</span>)
00082     {
00083       input1.push_back(sub1a);
00084       input1.push_back(sub1b);
00085       input2.push_back(sub2a);
00086       input2.push_back(sub2b);
00087     }
00088     <span class="keywordflow">else</span>
00089     {
00090       output1.push_back(input1[i]);
00091       output2.push_back(input2[i]);
00092     }
00093   }
00094 
00095   <span class="comment">// convert output from vector to string format</span>
00096   assert(outpu1.size() == output2.size());
00097   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; output1.size(); ++i)
00098   {
00099     assert(output1[i].size() == output2[i].size());
00100     std::string out1, out2;
00101     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; output1[i].size(); ++j)
00102     {
00103       <span class="keywordflow">if</span> (j &gt; 0 &amp;&amp; output1[i][j-1] != <span class="stringliteral">"("</span> &amp;&amp; output1[i][j] != <span class="stringliteral">")"</span>)
00104         out1 += ",";
00105       out1 += output1[i][j];
00106       
00107       if (j &gt; 0 &amp;&amp; output2[i][j-1] != "(" &amp;&amp; output2[i][j] != ")")
00108         out2 += ",";
00109       out2 += output2[i][j];
00110     }
00111     f1.push_back(out1);
00112     f2.push_back(out2);
00113   }
00114   
00115   return 0;
00116 }
00117 
00118 template&lt;class T&gt;
00119 <span class="keywordtype">bool</span> <a class="code" href="classExtractSplitsForest.html">ExtractSplitsForest</a>&lt;T&gt;::breakLCS(const std::vector&lt;std::string&gt;&amp; tree1,
00120                                      const std::vector&lt;std::string&gt;&amp; tree2,
00121                                      std::vector&lt;std::string&gt;&amp; subtree1a,
00122                                      std::vector&lt;std::string&gt;&amp; subtree1b,
00123                                      std::vector&lt;std::string&gt;&amp; subtree2a,
00124                                      std::vector&lt;std::string&gt;&amp; subtree2b)
00125 {
00126   std::set&lt;Split*&gt; splitSet1, splitSet2, intersection;
00127   getSplits(tree1, splitSet1);
00128   getSplits(tree2, splitSet2);
00129   
00130   std::set_intersection(splitSet1.begin(), splitSet1.end(), splitSet2.begin(),
00131                         splitSet2.end(), intersection.begin(), <a class="code" href="structSplitPLess.html">SplitPLess</a>());
00132 
00133   <span class="comment">// find the biggest common split</span>
00134   <span class="keywordtype">int</span> dif = std::numeric_limits&lt;int&gt;::max();
00135   std::set&lt;Split*&gt;::iterator i, j;
00136   <span class="keywordflow">for</span> (i = intersection.begin(); i != intersection.end(); ++i)
00137   {
00138     <span class="keywordtype">int</span> v = (int)abs((<span class="keywordtype">int</span>)(*i)-&gt;_rp - (<span class="keywordtype">int</span>)(*i)-&gt;size() / 2);
00139     <span class="keywordflow">if</span> (v &lt; dif)
00140     {
00141       dif = v;
00142       j = i;
00143     }
00144   }
00145   
00146   <span class="keywordflow">if</span> (dif != std::numeric_limits&lt;int&gt;::max())
00147   {  
00148     <span class="comment">// break the trees </span>
00149     splitTree(tree1, *j, subtree1a, subtree1b);
00150     splitTree(tree2, *splitSet2.find(j), subtree2a, subtree2b);
00151   }
00152 
00153   <span class="comment">// delete the splits</span>
00154   <span class="keywordflow">for</span> (i = splitSet1.begin(); i != splitSet1.end(); ++i)
00155     <span class="keyword">delete</span> *i;
00156   <span class="keywordflow">for</span> (i = splitSet2.begin(); i != splitSet2.end(); ++i)
00157     <span class="keyword">delete</span> *i;
00158 
00159   <span class="comment">// profit</span>
00160   <span class="keywordflow">return</span> !subtree1a.empty() &amp;&amp; subtree1a.size() &lt; tree1.size();
00161 }
00162 
00163 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00164 <span class="keywordtype">void</span> <a class="code" href="classExtractSplitsForest.html#b2">ExtractSplitsForest&lt;T&gt;::splitTree</a>(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; tree, 
00165                                        <span class="keyword">const</span> <a class="code" href="classSplit.html">Split</a>&amp; split,
00166                                        std::vector&lt;std::string&gt;&amp; sub1, 
00167                                        std::vector&lt;std::string&gt;&amp; sub2)
00168 {
00169   sub1.push_back(<span class="stringliteral">"("</span>);
00170   std::stringstream ss;
00171   ss &lt;&lt; _nextLabel;
00172   sub1.push_back(ss.str());
00173   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = split._left; i &lt;= split._right; ++i)
00174     sub1.push_back(tree[i]);
00175   sub1.push_back(")");
00176 
00177   for (<span class="keywordtype">int</span> i = 0; i &lt; split._left; ++i)
00178     sub2.push_back(tree[i]);
00179   sub2.push_back(_nextLabel);
00180   for (<span class="keywordtype">int</span> i = split._right + 1; i &lt; tree.size(); ++i)
00181     sub2.push_back(tree[i]);
00182 } 
00183 
00184 
00185 
00190 template&lt;class T&gt; 
00191 <span class="keywordtype">int</span> <a class="code" href="classExtractSplitsForest.html">ExtractSplitsForest</a>&lt;T&gt;::getSplits(const std::vector&lt;std::string&gt;&amp; tree, 
00192                                       std::set&lt;<a class="code" href="classSplit.html">Split</a>*&gt;&amp; splitset)
00193 {
00194   size_t i, j;
00195   size_t k = 0;
00196   size_t rbpos;
00197   <span class="keywordtype">int</span> state;
00198 
00199   <span class="keywordflow">for</span> (i = 1; i &lt; tree.size(); ++i)
00200   {
00201     <span class="keywordflow">if</span> (tree[i] == <span class="stringliteral">"("</span>)
00202     {
00203       <span class="comment">// first we find the matching right bracket</span>
00204       state = -1;
00205       <span class="keywordflow">for</span> (rbpos = i; state; ++rbpos)
00206       {
00207         <span class="keywordflow">if</span> (tree[rbpos] == <span class="stringliteral">")"</span>)
00208           ++state;
00209         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tree[rbpos] == <span class="stringliteral">"("</span>)
00210           --state;
00211         assert(rbpos &lt; tree.size());
00212       }
00213       
00214       <span class="comment">// create the split</span>
00215       <a class="code" href="classSplit.html">Split</a>* split = <span class="keyword">new</span> <a class="code" href="classSplit.html">Split</a>((tree.size() + 4 / 3));
00216       split-&gt;<a class="code" href="classSplit.html#o1">_left</a> = i;
00217       split-&gt;<a class="code" href="classSplit.html#o2">_right</a> = rbpos;
00218 
00219       <span class="comment">// copy in everything outside (i, rbpos)</span>
00220       <span class="keywordflow">for</span> (j = 0; j &lt; i; ++j)
00221       {
00222         <span class="keywordflow">if</span> (tree[j] != <span class="stringliteral">")"</span> &amp;&amp; tree[j] != <span class="stringliteral">"("</span>)
00223         {
00224           split-&gt;<a class="code" href="classCVector.html#a9">push_back</a>(tree[j]);
00225         }
00226       }
00227       <span class="keywordflow">for</span> (j = rbpos + 1; j &lt; tree.size(); ++j)
00228       {
00229         <span class="keywordflow">if</span> (tree[j] != <span class="stringliteral">")"</span> &amp;&amp; tree[j] != <span class="stringliteral">"("</span>)
00230         {
00231           _splits[k]-&gt;<a class="code" href="classCVector.html#a9">push_back</a>(tree[j].myLabel());
00232         }
00233       }
00234 
00235       <span class="comment">// copy everything inside (i, rbpos)</span>
00236       _splits[k]-&gt;<a class="code" href="classSplit.html#o0">_rp</a> = _splits[k]-&gt;<a class="code" href="classCVector.html#a13">size</a>();
00237       <span class="keywordflow">for</span> (j = i + 1; j &lt; rbpos; ++j)
00238       {
00239         <span class="keywordflow">if</span> (tree[j] != <span class="stringliteral">")"</span> &amp;&amp; tree[j] != <span class="stringliteral">"("</span>)
00240         {
00241           _splits[k]-&gt;<a class="code" href="classCVector.html#a9">push_back</a>(tree[j].myLabel());
00242         }
00243       }
00244 
00245       <span class="comment">// sort both halves of the split</span>
00246       std::sort(&amp;(*_splits[k])[0], &amp;(*_splits[k])[_splits[k]-&gt;_rp]);
00247       std::sort(&amp;(*_splits[k])[_splits[k]-&gt;_rp], 
00248                 &amp;(*_splits[k])[_splits[k]-&gt;size()]);
00249       
00250       <span class="comment">// if minimum leaf is not in the left split then swap the two</span>
00251       <span class="comment">// sides using _temp as a buffer</span>
00252       <span class="keywordflow">if</span> ((*_splits[k])[0] &gt; (*_splits[k])[_splits[k]-&gt;_rp])
00253       {
00254         _temp.<a class="code" href="classCVector.html#a12">clear</a>();
00255         <span class="keywordflow">for</span> (j = 0; j &lt; _splits[k]-&gt;_rp; ++j)
00256           _temp.push_back((*_splits[k])[j]);
00257         for (j = _splits[k]-&gt;_rp; j &lt; _splits[k]-&gt;size(); ++j)
00258           (*_splits[k])[j - _splits[k]-&gt;_rp] = (*_splits[k])[j];
00259         for (j = 0; j &lt; _temp.size(); ++j)
00260           (*_splits[k])[_splits[k]-&gt;size() - _splits[k]-&gt;_rp  + j] = _temp[j];
00261       }
00262       
00263       ++k;
00264 
00265       splitSet-&gt;insert(split);
00266     }
00267   }
00268   return splitSet-&gt;size();
00269 }
00270 
00271                                        
00272 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Oct 2 18:43:17 2006 for SPR by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
