<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SPR: splittable_impl.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>splittable_impl.h</h1><a href="splittable__impl_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#include &lt;set&gt;</span>
00002 
00003 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00004 <a class="code" href="classSplit.html#a0">Split&lt;T&gt;::Split</a>() : <a class="code" href="classCVector.html">CVector</a>&lt;T&gt;()
00005 {
00006 }
00007 
00008 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00009 <a class="code" href="classSplit.html#a0">Split&lt;T&gt;::Split</a>(size_t size) : <a class="code" href="classCVector.html">CVector</a>&lt;T&gt;(size)
00010 {
00011 }
00012 
00013 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
00014 <span class="keywordtype">bool</span> <a class="code" href="classSplit.html#a2">Split&lt;T&gt;::operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classSplit.html">Split&lt;T&gt;</a>&amp; split)<span class="keyword"> const</span>
00015 <span class="keyword"></span>{
00016   <span class="keywordflow">if</span> (_rp &lt; split._rp)
00017     return true;
00018   if (_rp &gt; split._rp)
00019     return false;
00020   for (size_t i = 0; i &lt; _rp; ++i)
00021   {
00022     <span class="keywordflow">if</span> (_array[i] &lt; split._array[i])
00023       return true;
00024     if (_array[i] &gt; split._array[i])
00025       return false;
00026   }
00027   return false;
00028 }
00029 
00030 template&lt;class T&gt;
<a name="l00031"></a><a class="code" href="structSplitPLess.html#a1">00031</a> <span class="keywordtype">bool</span> <a class="code" href="structSplitPLess.html">SplitPLess</a>&lt;T&gt;::operator()(<a class="code" href="classSplit.html">Split</a>&lt;T&gt;* s1, <a class="code" href="classSplit.html">Split</a>&lt;T&gt;* s2)
00032 {
00033   <span class="keywordflow">return</span> *s1 &lt; *s2;
00034 }
00035 
00036 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00037"></a><a class="code" href="splittable__impl_8h.html#a0">00037</a> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Split&lt;T&gt;&amp; split)
00038 {
00039   size_t i = 0;
00040   <span class="keywordflow">for</span> (; i &lt; split._rp; ++i)
00041     os &lt;&lt; (int)split[i]  &lt;&lt; <span class="charliteral">' '</span>;
00042   os &lt;&lt; <span class="stringliteral">" /"</span>;
00043   <span class="keywordflow">for</span> (; i &lt; split.size(); ++i)
00044     os &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; (int)split[i];
00045   
00046   <span class="keywordflow">return</span> os;
00047 }
00048 
00049 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00050"></a><a class="code" href="classSplitTable.html#a0">00050</a> <a class="code" href="classSplitTable.html#a0">SplitTable&lt;T&gt;::SplitTable</a>()
00051 {
00052 }
00053 
00054 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00055"></a><a class="code" href="classSplitTable.html#a1">00055</a> <a class="code" href="classSplitTable.html#a0">SplitTable&lt;T&gt;::SplitTable</a>(size_t size) : _splits(size)
00056 {
00057   <span class="keywordflow">for</span> (size_t i = 0; i &lt; size; ++i)
00058     <a class="code" href="classSplitTable.html#p0">_splits</a>[i] = NULL;
00059 }
00060 
00061 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00062"></a><a class="code" href="classSplitTable.html#a2">00062</a> <a class="code" href="classSplitTable.html#a2">SplitTable&lt;T&gt;::~SplitTable</a>()
00063 {
00064   <span class="keywordflow">for</span> (size_t i = 0; i &lt; <a class="code" href="classSplitTable.html#p0">_splits</a>.<a class="code" href="classCVector.html#a13">size</a>(); ++i)
00065     <span class="keyword">delete</span> <a class="code" href="classSplitTable.html#p0">_splits</a>[i];
00066 }
00067 
00068 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00069"></a><a class="code" href="classSplitTable.html#a3">00069</a> <span class="keywordtype">void</span> <a class="code" href="classSplitTable.html#a3">SplitTable&lt;T&gt;::resize</a>(size_t numLeaves)
00070 {
00071   size_t oldN = std::max(0, (<span class="keywordtype">int</span>)<a class="code" href="classSplitTable.html#p0">_splits</a>.<a class="code" href="classCVector.html#a13">size</a>() - 3);
00072   size_t i;
00073 
00074   <span class="keywordflow">for</span> (i = numLeaves - 3; i &lt; oldN; ++i)
00075     <span class="keyword">delete</span> <a class="code" href="classSplitTable.html#p0">_splits</a>[i];
00076 
00077   <a class="code" href="classSplitTable.html#p0">_splits</a>.<a class="code" href="classCVector.html#a14">setSize</a>(numLeaves - 3);
00078   <a class="code" href="classSplitTable.html#p0">_splits</a>.<a class="code" href="classCVector.html#a11">reserve</a>(numLeaves - 2);
00079 
00080   <span class="keywordflow">for</span> (i = 0; i &lt; oldN; ++i)
00081     <a class="code" href="classSplitTable.html#p0">_splits</a>[i]-&gt;<a class="code" href="classCVector.html#a11">reserve</a>(numLeaves + 1);
00082 
00083   <span class="keywordflow">for</span> (i = oldN; i &lt; <a class="code" href="classSplitTable.html#p0">_splits</a>.<a class="code" href="classCVector.html#a13">size</a>(); ++i)
00084     <a class="code" href="classSplitTable.html#p0">_splits</a>[i] = <span class="keyword">new</span> <a class="code" href="classSplit.html">Split&lt;T&gt;</a>(numLeaves + 1);
00085 }
00086 
00087 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00088"></a><a class="code" href="classSplitTable.html#a4">00088</a> <span class="keywordtype">int</span> <a class="code" href="classSplitTable.html#a4">SplitTable&lt;T&gt;::getSize</a>()<span class="keyword"> const</span>
00089 <span class="keyword"></span>{
00090   <span class="keywordflow">return</span> <a class="code" href="classSplitTable.html#p0">_splits</a>.<a class="code" href="classCVector.html#a13">size</a>();
00091 }
00092 
00093 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00094"></a><a class="code" href="classSplitTable.html#a5">00094</a> <span class="keyword">const</span> <a class="code" href="classSplit.html">Split&lt;T&gt;</a>&amp; <a class="code" href="classSplitTable.html#a5">SplitTable&lt;T&gt;::operator[]</a>(size_t i)<span class="keyword"> const</span>
00095 <span class="keyword"></span>{
00096   <span class="keywordflow">return</span> *<a class="code" href="classSplitTable.html#p0">_splits</a>[i];
00097 }
00098 
00099 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; 
<a name="l00100"></a><a class="code" href="classSplitTable.html#a6">00100</a> <span class="keywordtype">void</span> <a class="code" href="classSplitTable.html#a6">SplitTable&lt;T&gt;::loadTree</a>(<span class="keyword">const</span> <a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>&amp; tree, 
00101                              <span class="keyword">const</span> <a class="code" href="classBracketTable.html">BracketTable&lt;T&gt;</a>&amp; btable)
00102 {
00103   <a class="code" href="classSplitTable.html#a3">resize</a>(tree._man-&gt;numLeaves());
00104 
00105   size_t i, j;
00106   size_t k = 0;
00107 
00108   <span class="keywordflow">for</span> (i = 1; i &lt; static_cast&lt;size_t&gt;(tree.size()); ++i)
00109   {
00110     <span class="keywordflow">if</span> (tree[i].myType() == <a class="code" href="treetok_8h.html#a4a0">LB</a>)
00111     {
00112       <a class="code" href="classSplitTable.html#p0">_splits</a>[k]-&gt;<a class="code" href="classCVector.html#a12">clear</a>();
00113       <span class="keywordflow">for</span> (j = 0; j &lt; i; ++j)
00114       {
00115         <span class="keywordflow">if</span> (tree[j].myType() == <a class="code" href="treetok_8h.html#a4a2">LEAF</a>)
00116         {
00117           <a class="code" href="classSplitTable.html#p0">_splits</a>[k]-&gt;<a class="code" href="classCVector.html#a9">push_back</a>(tree[j].myLabel());
00118         }
00119       }
00120       <span class="keywordflow">for</span> (j = btable[i].pos[1] + 1; j &lt; tree.size(); ++j)
00121       {
00122                 <span class="keywordflow">if</span> (tree[j].myType() == <a class="code" href="treetok_8h.html#a4a2">LEAF</a>)
00123         {
00124           <a class="code" href="classSplitTable.html#p0">_splits</a>[k]-&gt;<a class="code" href="classCVector.html#a9">push_back</a>(tree[j].myLabel());
00125         }
00126       }
00127       <a class="code" href="classSplitTable.html#p0">_splits</a>[k]-&gt;_rp = <a class="code" href="classSplitTable.html#p0">_splits</a>[k]-&gt;<a class="code" href="classCVector.html#a13">size</a>();
00128       <span class="keywordflow">for</span> (j = i + 1; j &lt; btable[i].pos[1]; ++j)
00129       {
00130         <span class="keywordflow">if</span> (tree[j].myType() == <a class="code" href="treetok_8h.html#a4a2">LEAF</a>)
00131         {
00132           <a class="code" href="classSplitTable.html#p0">_splits</a>[k]-&gt;<a class="code" href="classCVector.html#a9">push_back</a>(tree[j].myLabel());
00133         }
00134       }
00135 
00136       std::sort(&amp;(*<a class="code" href="classSplitTable.html#p0">_splits</a>[k])[0], &amp;(*<a class="code" href="classSplitTable.html#p0">_splits</a>[k])[<a class="code" href="classSplitTable.html#p0">_splits</a>[k]-&gt;_rp]);
00137       std::sort(&amp;(*<a class="code" href="classSplitTable.html#p0">_splits</a>[k])[<a class="code" href="classSplitTable.html#p0">_splits</a>[k]-&gt;_rp], 
00138                 &amp;(*<a class="code" href="classSplitTable.html#p0">_splits</a>[k])[<a class="code" href="classSplitTable.html#p0">_splits</a>[k]-&gt;size()]);
00139       
00140       <span class="comment">// if minimum leaf is not in the left split then swap the two</span>
00141       <span class="comment">// sides using _temp as a buffer</span>
00142       <span class="keywordflow">if</span> ((*<a class="code" href="classSplitTable.html#p0">_splits</a>[k])[0] &gt; (*<a class="code" href="classSplitTable.html#p0">_splits</a>[k])[<a class="code" href="classSplitTable.html#p0">_splits</a>[k]-&gt;_rp])
00143       {
00144         <a class="code" href="classSplitTable.html#p1">_temp</a>.<a class="code" href="classCVector.html#a12">clear</a>();
00145         <span class="keywordflow">for</span> (j = 0; j &lt; _splits[k]-&gt;_rp; ++j)
00146           <a class="code" href="classSplitTable.html#p1">_temp</a>.<a class="code" href="classCVector.html#a9">push_back</a>((*<a class="code" href="classSplitTable.html#p0">_splits</a>[k])[j]);
00147         <span class="keywordflow">for</span> (j = <a class="code" href="classSplitTable.html#p0">_splits</a>[k]-&gt;_rp; j &lt; _splits[k]-&gt;size(); ++j)
00148           (*<a class="code" href="classSplitTable.html#p0">_splits</a>[k])[j - <a class="code" href="classSplitTable.html#p0">_splits</a>[k]-&gt;_rp] = (*_splits[k])[j];
00149         <span class="keywordflow">for</span> (j = 0; j &lt; <a class="code" href="classSplitTable.html#p1">_temp</a>.size(); ++j)
00150           (*_splits[k])[_splits[k]-&gt;size() - _splits[k]-&gt;_rp  + j] = <a class="code" href="classSplitTable.html#p1">_temp</a>[j];
00151       }
00152       
00153       ++k;
00154     }
00155   }
00156 
00157   std::sort(&amp;<a class="code" href="classSplitTable.html#p0">_splits</a>[0], &amp;<a class="code" href="classSplitTable.html#p0">_splits</a>[<a class="code" href="classSplitTable.html#p0">_splits</a>.<a class="code" href="classCVector.html#a13">size</a>()], <a class="code" href="structSplitPLess.html">SplitPLess&lt;T&gt;</a>());
00158     
00159 }
00160 
00161 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00162"></a><a class="code" href="classSplitTable.html#a7">00162</a> <span class="keyword">const</span> <a class="code" href="classSplit.html">Split&lt;T&gt;</a>* <a class="code" href="classSplitTable.html#a7">SplitTable&lt;T&gt;::lcs</a>(<span class="keyword">const</span> <a class="code" href="classSplitTable.html">SplitTable&lt;T&gt;</a>&amp; table)<span class="keyword"> const</span>
00163 <span class="keyword"></span>{
00164 
00165   <span class="comment">// placeholder.  d'oh!</span>
00166   std::vector&lt;Split&lt;T&gt;*&gt; s1, s2, s3;
00167   <span class="keywordflow">for</span> (size_t i = 0; i &lt; <a class="code" href="classSplitTable.html#p0">_splits</a>.<a class="code" href="classCVector.html#a13">size</a>(); ++i)
00168     s1.<a class="code" href="classCVector.html#a9">push_back</a>(<a class="code" href="classSplitTable.html#p0">_splits</a>[i]);
00169   std::sort(s1.begin(), s1.end(), <a class="code" href="structSplitPLess.html">SplitPLess&lt;T&gt;</a>());
00170   <span class="keywordflow">for</span> (size_t i = 0; i &lt; table._splits.size(); ++i)
00171     s2.<a class="code" href="classCVector.html#a9">push_back</a>(table._splits[i]);
00172   std::sort(s2.begin(), s2.end(), <a class="code" href="structSplitPLess.html">SplitPLess&lt;T&gt;</a>());
00173   
00174 <span class="comment">//  std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), s3.begin(),</span>
00175 <span class="comment">//                        SplitPLess&lt;T&gt;());</span>
00176 
00177   <span class="keywordflow">for</span> (size_t i = 0; i &lt; s1.size(); ++i)
00178   {
00179     <span class="keywordflow">for</span> (size_t j = 0; j &lt; s2.size(); ++j)
00180     {
00181       <a class="code" href="structSplitPLess.html">SplitPLess&lt;T&gt;</a> pl;
00182       <span class="keywordflow">if</span> (pl(s1[i], s2[j]) == <span class="keyword">false</span> &amp;&amp; pl(s2[j], s1[i]) == <span class="keyword">false</span>)
00183       {
00184         s3.<a class="code" href="classCVector.html#a9">push_back</a>(s1[i]);
00185         std::cout &lt;&lt; *s1[i] &lt;&lt; std::endl;
00186       }
00187     }
00188 <span class="comment">//    if (std::binary_search(s2.begin(), s2.end(), s1[i], SplitPLess&lt;T&gt;()))</span>
00189 <span class="comment">//      s3.push_back(s1[i]);</span>
00190   }
00191 
00192   <a class="code" href="classSplit.html">Split&lt;T&gt;</a>* min = NULL;
00193   size_t mval = <a class="code" href="classSplitTable.html#p0">_splits</a>.<a class="code" href="classCVector.html#a13">size</a>();
00194   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::vector&lt;<a class="code" href="classSplit.html">Split&lt;T&gt;</a>*&gt;::iterator it = s3.begin(); 
00195        it != s3.end(); ++it)
00196   {
00197     <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)abs((<span class="keywordtype">int</span>)(*it)-&gt;_rp - (<span class="keywordtype">int</span>)(*it)-&gt;size() / 2) &lt; mval)
00198     {
00199       min = *it;
00200       mval = (int)abs((<span class="keywordtype">int</span>)(*it)-&gt;_rp - (<span class="keywordtype">int</span>)(*it)-&gt;size() / 2);
00201     }
00202   }
00203 
00204   <span class="keywordflow">return</span> min;
00205 }
00206 
00207 <span class="comment">/*template&lt;class T&gt;</span>
00208 <span class="comment">int SplitTable&lt;T&gt;::intersection(const SplitTable&lt;T&gt;&amp; itable, </span>
00209 <span class="comment">                                      SplitTable&lt;T&gt;&amp; otable) const</span>
00210 <span class="comment">{</span>
00211 <span class="comment">  return -1;</span>
00212 <span class="comment">}</span>
00213 <span class="comment">*/</span>
00214 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00215"></a><a class="code" href="splittable__impl_8h.html#a1">00215</a> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const SplitTable&lt;T&gt;&amp; table)
00216 {
00217   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; table.getSize(); ++i)
00218     os &lt;&lt; table[i] &lt;&lt; std::endl;
00219   <span class="keywordflow">return</span> os;
00220 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Oct 2 18:43:18 2006 for SPR by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
