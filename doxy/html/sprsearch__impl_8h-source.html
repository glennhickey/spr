<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SPR: sprsearch_impl.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>sprsearch_impl.h</h1><a href="sprsearch__impl_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#ifndef _SPRSEARCH_IMPL_H</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define _SPRSEARCH_IMPL_H</span>
00003 <span class="preprocessor"></span>
00009 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00010"></a><a class="code" href="classSPRSearch.html#a0">00010</a> <a class="code" href="classSPRSearch.html#d0">SPRSearch&lt;T&gt;::SPRSearch</a>(<a class="code" href="classTreeManager.html">TreeManager&lt;T&gt;</a>&amp; man, <a class="code" href="classTreeCache.html">TreeCache&lt;T&gt;</a>&amp; cache, 
00011                         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <span class="keywordtype">id</span>) :
00012   _pool1(&amp;_p1), _pool2(&amp;_p2), _man(man), _valid(man.treeSize()), _kern(man), 
00013   _cache(cache), _btable1(NULL), _btable2(man.treeSize()), 
00014   _ftable1(NULL), _ftable2(man.treeSize()), 
00015   _sprTable1(man.treeSize()), _sprTable2(man.treeSize()), 
00016   _sprHelper(_kern.numLeaves()), _lookup1(NULL), _id(id), _iter(0)
00017 {
00018   <a class="code" href="classSPRSearch.html#p2">_p1</a>.<a class="code" href="classCVector.html#a11">reserve</a>(1024);
00019   <a class="code" href="classSPRSearch.html#p3">_p2</a>.<a class="code" href="classCVector.html#a11">reserve</a>(1024);
00020   <a class="code" href="classSPRSearch.html#p4">_man</a>.createTree(<a class="code" href="classSPRSearch.html#p9">_treeBuf1</a>);
00021   <a class="code" href="classSPRSearch.html#p4">_man</a>.createTree(<a class="code" href="classSPRSearch.html#p10">_treeBuf2</a>);
00022 }
00023 
00024 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00025"></a><a class="code" href="classSPRSearch.html#a1">00025</a> <a class="code" href="classSPRSearch.html#a1">SPRSearch&lt;T&gt;::~SPRSearch</a>()
00026 {
00027   <span class="comment">// note that treebuf1 and treebuf2 are lost here (but not leaked)</span>
00028 }
00029 
00033 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00034"></a><a class="code" href="classSPRSearch.html#a2">00034</a> <span class="keywordtype">void</span> <a class="code" href="classSPRSearch.html#a2">SPRSearch&lt;T&gt;::setStartTree</a>(<span class="keyword">const</span> <a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>&amp; t1)
00035 {
00036   <a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a12">clear</a>();
00037   <a class="code" href="classSPRSearch.html#p1">_pool2</a>-&gt;<a class="code" href="classCVector.html#a12">clear</a>();
00038   <a class="code" href="classSPRSearch.html#o2">_count</a> = <a class="code" href="classSPRSearch.html#o3">_cacheHits</a> = 0;
00039 
00040   <a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a> t1Copy;
00041   <a class="code" href="classSPRSearch.html#p4">_man</a>.createTree(t1Copy);
00042   t1Copy.<a class="code" href="structUPTree.html#a2">duplicate</a>(t1);
00043 
00044   <a class="code" href="classSPRSearch.html#p5">_valid</a>.retrifurcate(t1Copy, <a class="code" href="classSPRSearch.html#p9">_treeBuf1</a>, 0);
00045   <a class="code" href="classSPRSearch.html#p5">_valid</a>.reorder(<a class="code" href="classSPRSearch.html#p9">_treeBuf1</a>, t1Copy);
00046   <a class="code" href="classSPRSearch.html#p7">_cache</a>.update(t1Copy, <a class="code" href="classSPRSearch.html#p19">_id</a>, <a class="code" href="classSPRSearch.html#p20">_iter</a>);
00047 
00048 <span class="preprocessor">#ifdef REKERNELIZE</span>
00049 <span class="preprocessor"></span>  <a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a9">push_back</a>(std::pair&lt;<a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>, T&gt;(t1Copy, 0));
00050 <span class="preprocessor">#else  </span>
00051 <span class="preprocessor"></span>  <a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a9">push_back</a>(t1Copy);
00052 <span class="preprocessor">#endif</span>
00053 <span class="preprocessor"></span>}
00054 
00059 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00060"></a><a class="code" href="classSPRSearch.html#a3">00060</a> <span class="keywordtype">void</span> <a class="code" href="classSPRSearch.html#a3">SPRSearch&lt;T&gt;::setEndTree</a>(<span class="keyword">const</span> <a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>&amp; t2)
00061 {
00062   <a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a> t2Copy;
00063   <a class="code" href="classSPRSearch.html#p4">_man</a>.createTree(t2Copy);
00064   t2Copy.<a class="code" href="structUPTree.html#a2">duplicate</a>(t2);
00065 
00066   <a class="code" href="classSPRSearch.html#p5">_valid</a>.retrifurcate(t2Copy, <a class="code" href="classSPRSearch.html#p9">_treeBuf1</a>, 0);
00067   <a class="code" href="classSPRSearch.html#p5">_valid</a>.reorder(<a class="code" href="classSPRSearch.html#p9">_treeBuf1</a>, t2Copy);
00068   <a class="code" href="classSPRSearch.html#p7">_cache</a>.update(t2Copy, !<a class="code" href="classSPRSearch.html#p19">_id</a>, <a class="code" href="classSPRSearch.html#p20">_iter</a>);
00069 
00070   <a class="code" href="classSPRSearch.html#p6">_kern</a>.setT2(t2Copy);
00071 }
00072 
00081 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00082"></a><a class="code" href="classSPRSearch.html#a4">00082</a> <span class="keywordtype">bool</span> <a class="code" href="classSPRSearch.html#a4">SPRSearch&lt;T&gt;::iterate</a>()
00083 {
00084   <span class="keywordflow">if</span> (!<a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a15">empty</a>())
00085   {
00086     <a class="code" href="classSPRSearch.html#p1">_pool2</a>-&gt;<a class="code" href="classCVector.html#a12">clear</a>();
00087     ++<a class="code" href="classSPRSearch.html#p20">_iter</a>;
00088     size_t n = <a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a13">size</a>();
00089     size_t i;
00090 
00091 <span class="preprocessor">#ifdef SORTPOOL</span>
00092 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i = 0; i &lt; n; ++i)
00093     {
00094       <a class="code" href="classSPRSearch.html#p6">_kern</a>.setT1(<a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i).first);
00095       <a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i).second = <a class="code" href="classSPRSearch.html#p6">_kern</a>.kernelize();
00096     }
00097     <span class="keywordflow">if</span> (!<a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a15">empty</a>())
00098       std::sort(&amp;<a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(0), &amp;<a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(<a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a13">size</a>() - 1), PairComp());
00099 <span class="preprocessor">#endif</span>
00100 <span class="preprocessor"></span>
00101     <span class="keywordflow">for</span> (i = 0; i &lt; n; ++i)
00102     {
00103 <span class="preprocessor">#ifdef REKERNELIZE      </span>
00104 <span class="preprocessor"></span>      <a class="code" href="classSPRSearch.html#p6">_kern</a>.setT1(<a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i).first);
00105       
00106       <span class="comment">// OK, this second rekernelization (which happens if SORTPOOL is defined</span>
00107       <span class="comment">// is totally a design flaw) and is due to the fact that flag</span>
00108       <span class="comment">// information was moved out of the trees and into the flagtables</span>
00109       <span class="comment">// which are not stored.  Luckily, the extra kernelization isn't</span>
00110       <span class="comment">// terribly costly but this should get fixed at some point...</span>
00111       <a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i).second = <a class="code" href="classSPRSearch.html#p6">_kern</a>.kernelize();
00112 <span class="preprocessor">#else</span>
00113 <span class="preprocessor"></span>      <a class="code" href="classSPRSearch.html#p6">_kern</a>.setT1(<a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i));
00114 <span class="preprocessor">#endif</span>
00115 <span class="preprocessor"></span>      <span class="comment">// get table information associated with _pool1-&gt;at(i) tree.</span>
00116       <span class="comment">// note that even if kernelize() wasn't called, it is still set</span>
00117       <span class="comment">// by _kern.setT1()</span>
00118       <a class="code" href="classSPRSearch.html#p11">_btable1</a> = &amp;<a class="code" href="classSPRSearch.html#p6">_kern</a>.getBTable(0);
00119       <a class="code" href="classSPRSearch.html#p13">_ftable1</a> = &amp;<a class="code" href="classSPRSearch.html#p6">_kern</a>.getFTable(0);
00120       <a class="code" href="classSPRSearch.html#p18">_lookup1</a> = <a class="code" href="classSPRSearch.html#p6">_kern</a>.getLookup(0);
00121 
00122       <span class="comment">// evaluate all 2n-6 NNI neighbours of ith tree in pool1</span>
00123       <span class="comment">// unique results go into pool2</span>
00124 <span class="preprocessor">#ifdef REKERNELIZE</span>
00125 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (<a class="code" href="classSPRSearch.html#b0">evaluateNNI</a>(<a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i).first))
00126 <span class="preprocessor">#else</span>
00127 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (<a class="code" href="classSPRSearch.html#b0">evaluateNNI</a>(<a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i)))
00128 <span class="preprocessor">#endif</span>
00129 <span class="preprocessor"></span>      {
00130         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00131       }
00132       <span class="comment">// evaluate SPR neighbours that aren't NNI's of the same tree</span>
00133       <span class="comment">// again putting uniqe results into pool 2</span>
00134 <span class="preprocessor">#ifdef REKERNELIZE</span>
00135 <span class="preprocessor"></span>      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classSPRSearch.html#b1">evaluateSPR</a>(<a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i).first))
00136 <span class="preprocessor">#else</span>
00137 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (<a class="code" href="classSPRSearch.html#b1">evaluateSPR</a>(<a class="code" href="classSPRSearch.html#p0">_pool1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i)))
00138 <span class="preprocessor">#endif</span>
00139 <span class="preprocessor"></span>      {
00140         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00141       }
00142     }
00143     std::swap(<a class="code" href="classSPRSearch.html#p0">_pool1</a>, <a class="code" href="classSPRSearch.html#p1">_pool2</a>);
00144 <span class="comment">/*</span>
00145 <span class="comment">#ifdef REKERNELIZE</span>
00146 <span class="comment">    for (size_t j = 0; j &lt; _pool1-&gt;size(); ++j)</span>
00147 <span class="comment">    {</span>
00148 <span class="comment">      _kern.setT1(_pool1-&gt;at(j).first);</span>
00149 <span class="comment">      _pool1-&gt;at(j).second = _kern.kernelize();</span>
00150 <span class="comment">      std::cout &lt;&lt; *_ftable1 &lt;&lt; "\n" &lt;&lt; _kern.getFTable(0) &lt;&lt; "\n\n";</span>
00151 <span class="comment">    }</span>
00152 <span class="comment">#ifdef SORTPOOL</span>
00153 <span class="comment">    if (!_pool1-&gt;empty())</span>
00154 <span class="comment">      std::sort(&amp;_pool1-&gt;at(0), &amp;_pool1-&gt;at(_pool1-&gt;size() - 1), PairComp());</span>
00155 <span class="comment">#endif</span>
00156 <span class="comment">//    if (_pool1-&gt;size() &gt; 173)</span>
00157 <span class="comment">//      _pool1-&gt;setSize(173);</span>
00158 <span class="comment">#endif</span>
00159 <span class="comment">*/</span>
00160   }
00161   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00162 }
00163 
00169 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00170"></a><a class="code" href="classSPRSearch.html#b0">00170</a> <span class="keywordtype">bool</span> <a class="code" href="classSPRSearch.html#b0">SPRSearch&lt;T&gt;::evaluateNNI</a>(<a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>&amp; tree)
00171 {
00172   <span class="keywordtype">int</span> i;
00173   <span class="keywordtype">int</span> lsub[2]; <span class="comment">// left and right index of left subtree</span>
00174   <span class="keywordtype">int</span> rsub[2]; <span class="comment">// left and right index of right subtree</span>
00175   <span class="keywordtype">int</span> nsub[2]; <span class="comment">// left and right index of "nesting subtree"</span>
00176   <a class="code" href="classSPRSearch.html#o0">_nniCount</a> = 0; <span class="comment">// count nieghbours for debugging</span>
00177  
00178   <span class="comment">// nni will generate 2 trees: swap(left subtree, nesting subtree)</span>
00179   <span class="comment">// and swap(right subtree, nesting subtree)</span>
00180   
00181   <span class="comment">// we reuse the brackettable and tripos info from the kernelization</span>
00182   <span class="keywordtype">int</span> triPos1 = <a class="code" href="classSPRSearch.html#p11">_btable1</a>-&gt;getTriPos(1);
00183   <span class="keywordtype">int</span> triPos2 = <a class="code" href="classSPRSearch.html#p11">_btable1</a>-&gt;getTriPos(2);
00184 
00185   <span class="comment">// start with all the nni's (there are 2 for each bracket pair</span>
00186   <span class="comment">// not including the first and last brackets). </span>
00187   <span class="keywordflow">for</span> (i = 1; i &lt; tree.size() - 1; ++i)
00188   {
00189 <span class="preprocessor">#ifdef REKERNELIZE</span>
00190 <span class="preprocessor"></span>    
00191     <span class="keywordflow">if</span> (<a class="code" href="classSPRSearch.html#p13">_ftable1</a>-&gt;isFrozen(i) == <span class="keyword">true</span>)
00192     {
00193       <span class="keywordflow">continue</span>;
00194     }
00195 <span class="preprocessor">#endif</span>
00196 <span class="preprocessor"></span>    <span class="comment">// if we find a left bracket, evaluate the 2 NNI's that</span>
00197     <span class="comment">// it and its matching right bracket correspond to. </span>
00198     <span class="keywordflow">if</span> (tree[i].myType() == <a class="code" href="treetok_8h.html#a4a0">LB</a>)
00199     {
00200         <span class="comment">// find start and end points of nested subtrees</span>
00201         lsub[0] = i + 1;
00202         lsub[1] = <a class="code" href="classSPRSearch.html#p11">_btable1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i).rPos - 1;
00203         rsub[0] = <a class="code" href="classSPRSearch.html#p11">_btable1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i).rPos;
00204         rsub[1] = <a class="code" href="classSPRSearch.html#p11">_btable1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i).pos[1] - 1;
00205       
00206         <span class="comment">// find "nesting" subtree</span>
00207         <span class="keywordflow">if</span> (i != triPos1 &amp;&amp; i != triPos2)
00208         {
00209           <span class="comment">// it's to the right</span>
00210           <span class="keywordflow">if</span> (tree[i-1].myType() == <a class="code" href="treetok_8h.html#a4a0">LB</a>)
00211             nsub[0] = <a class="code" href="classSPRSearch.html#p11">_btable1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i).pos[1] + 1;
00212           <span class="comment">// it's to the left</span>
00213           <span class="keywordflow">else</span>
00214             nsub[0] = <a class="code" href="classSPRSearch.html#p11">_btable1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(i - 1).pos[0];
00215         }
00216         <span class="keywordflow">else</span>
00217         {
00218           <span class="comment">// it's the 3rd trifurcation</span>
00219           <span class="keywordflow">if</span> (i == triPos1)
00220             nsub[0] = triPos2;
00221           <span class="comment">// it's the 2nd trifurcation</span>
00222           <span class="keywordflow">else</span>
00223             nsub[0] = triPos1;
00224         }
00225         nsub[1] = <a class="code" href="classSPRSearch.html#p11">_btable1</a>-&gt;<a class="code" href="classCVector.html#a6">at</a>(nsub[0]).pos[1];
00226       
00227         <span class="comment">// make the first nni tree</span>
00228         <a class="code" href="classSPRSearch.html#p4">_man</a>.createTree(<a class="code" href="classSPRSearch.html#p8">_sprNeighbour</a>);
00229         <a class="code" href="classSPRSearch.html#b2">swapCopy</a>(tree, <a class="code" href="classSPRSearch.html#p8">_sprNeighbour</a>, lsub, nsub);
00230         <span class="keywordflow">if</span> (<a class="code" href="classSPRSearch.html#b4">updateCache</a>(<a class="code" href="classSPRSearch.html#p8">_sprNeighbour</a>))
00231           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00232      
00233         <span class="comment">// make the second nni tree</span>
00234         <a class="code" href="classSPRSearch.html#p4">_man</a>.createTree(<a class="code" href="classSPRSearch.html#p8">_sprNeighbour</a>);
00235         <a class="code" href="classSPRSearch.html#b2">swapCopy</a>(tree, <a class="code" href="classSPRSearch.html#p8">_sprNeighbour</a>, rsub, nsub);
00236         <span class="keywordflow">if</span> (<a class="code" href="classSPRSearch.html#b4">updateCache</a>(<a class="code" href="classSPRSearch.html#p8">_sprNeighbour</a>))
00237           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00238 
00239         <a class="code" href="classSPRSearch.html#o0">_nniCount</a> += 2;
00240       }
00241   }
00242 <span class="preprocessor">#ifndef REKERNELIZE</span>
00243 <span class="preprocessor"></span>  assert(<a class="code" href="classSPRSearch.html#o0">_nniCount</a>  == 2 * <a class="code" href="classSPRSearch.html#p6">_kern</a>.numLeaves() - 6); 
00244 <span class="preprocessor">#endif</span>
00245 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <span class="keyword">false</span>;
00246 }
00247 
00253 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00254"></a><a class="code" href="classSPRSearch.html#b1">00254</a> <span class="keywordtype">bool</span> <a class="code" href="classSPRSearch.html#b1">SPRSearch&lt;T&gt;::evaluateSPR</a>(<a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>&amp; tree)
00255 {
00256   <span class="keywordtype">int</span> i,j;
00257   <a class="code" href="classSPRSearch.html#o1">_sprCount</a> = 0;
00258 
00259   <a class="code" href="classSPRSearch.html#p15">_sprTable1</a>.loadTree(tree, *<a class="code" href="classSPRSearch.html#p11">_btable1</a>);
00260 
00261   <span class="comment">// DEBUG</span>
00262   <span class="keywordtype">int</span> sprTemp = 0;
00263   
00264   <span class="keywordflow">for</span> (i = 1; i &lt; tree.size() - 1; ++i)
00265   {
00266 <span class="preprocessor">#ifdef REKERNELIZE</span>
00267 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="classSPRSearch.html#p13">_ftable1</a>-&gt;isFrozen(i) == <span class="keyword">true</span>)
00268     {
00269       <span class="keywordflow">continue</span>;
00270     }
00271 <span class="preprocessor">#endif</span>
00272 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (j = 0; j &lt; <a class="code" href="classSPRSearch.html#p15">_sprTable1</a>[i]._num; ++j)
00273     {
00274 <span class="preprocessor">#ifdef REKERNELIZE</span>
00275 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (<a class="code" href="classSPRSearch.html#p13">_ftable1</a>-&gt;isFrozen(<a class="code" href="classSPRSearch.html#p15">_sprTable1</a>[i]._pos[j]) == <span class="keyword">true</span>)
00276       {
00277         <span class="keywordflow">continue</span>;
00278       }
00279 <span class="preprocessor">#endif</span>
00280 <span class="preprocessor"></span>      <a class="code" href="classSPRSearch.html#p4">_man</a>.createTree(<a class="code" href="classSPRSearch.html#p8">_sprNeighbour</a>);
00281       <a class="code" href="classSPRSearch.html#b3">sprCopy</a>(tree, <a class="code" href="classSPRSearch.html#p8">_sprNeighbour</a>, i, <a class="code" href="classSPRSearch.html#p15">_sprTable1</a>[i]._pos[j], *<a class="code" href="classSPRSearch.html#p11">_btable1</a>, 
00282               *<a class="code" href="classSPRSearch.html#p13">_ftable1</a>);
00283       <span class="keywordflow">if</span> (<a class="code" href="classSPRSearch.html#b4">updateCache</a>(<a class="code" href="classSPRSearch.html#p8">_sprNeighbour</a>))
00284       {
00285         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00286       }
00287       ++<a class="code" href="classSPRSearch.html#o1">_sprCount</a>;
00288       ++sprTemp;
00289     }
00290        
00291     <span class="keywordflow">if</span> (tree[i].myType() == <a class="code" href="treetok_8h.html#a4a0">LB</a>)
00292     {
00293       <span class="comment">// 1)reroot with anything inside subtree, flagging subtree first</span>
00294       <a class="code" href="classSPRSearch.html#p17">_sprHelper</a>.flagSubtree(tree, i, *<a class="code" href="classSPRSearch.html#p11">_btable1</a>);
00295       <a class="code" href="classSPRSearch.html#p5">_valid</a>.retrifurcate(tree, <a class="code" href="classSPRSearch.html#p10">_treeBuf2</a>, 
00296                           <a class="code" href="classSprHelper.html">SprHelper&lt;T&gt;</a>::nextLeafLabel(tree, i));
00297 
00298       <span class="comment">// 2)build a new brackettable</span>
00299       <a class="code" href="classSPRSearch.html#p12">_btable2</a>.loadTree(<a class="code" href="classSPRSearch.html#p10">_treeBuf2</a>);
00300 
00301       <span class="comment">// 3)make sure flags are properly perserved</span>
00302       <a class="code" href="classSPRSearch.html#p14">_ftable2</a>.loadTree(<a class="code" href="classSPRSearch.html#p10">_treeBuf2</a>, <a class="code" href="classSPRSearch.html#p12">_btable2</a>);
00303       <a class="code" href="classSPRSearch.html#p14">_ftable2</a>.copy(*<a class="code" href="classSPRSearch.html#p13">_ftable1</a>, <a class="code" href="classSPRSearch.html#p18">_lookup1</a>);
00304       <a class="code" href="classSPRSearch.html#p14">_ftable2</a>.updateRekern();
00305 
00306       <span class="comment">// 4)locate left bracket of "outside" subtree.  </span>
00307       <span class="keywordtype">int</span> outSub = <a class="code" href="classSPRSearch.html#p17">_sprHelper</a>.getFlaggedInverse(<a class="code" href="classSPRSearch.html#p10">_treeBuf2</a>, <a class="code" href="classSPRSearch.html#p12">_btable2</a>);
00308 
00309       <span class="comment">// 5)rebuild an sprtable for target subtree of retrifurcated tree</span>
00310       <a class="code" href="classSPRSearch.html#p16">_sprTable2</a>.loadSubtree(<a class="code" href="classSPRSearch.html#p10">_treeBuf2</a>, outSub, <a class="code" href="classSPRSearch.html#p12">_btable2</a>);
00311 
00312       <span class="comment">// 6)perform all possible sprs with this subtree</span>
00313       <span class="keywordflow">for</span> (j = 0; j &lt; <a class="code" href="classSPRSearch.html#p16">_sprTable2</a>[outSub]._num; ++j)
00314       {
00315 <span class="preprocessor">#ifdef REKERNELIZE</span>
00316 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="classSPRSearch.html#p14">_ftable2</a>.isFrozen(<a class="code" href="classSPRSearch.html#p16">_sprTable2</a>[outSub]._pos[j]))
00317         {
00318           <span class="keywordflow">continue</span>;
00319         }
00320 <span class="preprocessor">#endif</span>
00321 <span class="preprocessor"></span>        <a class="code" href="classSPRSearch.html#p4">_man</a>.createTree(<a class="code" href="classSPRSearch.html#p8">_sprNeighbour</a>);
00322 
00323 <span class="comment">/*            std::cout &lt;&lt; "SPR CPY SRC= " &lt;&lt; _treeBuf2  &lt;&lt; "    "</span>
00324 <span class="comment">              &lt;&lt; outSub &lt;&lt; " --&gt; " &lt;&lt; _sprTable2[outSub]._pos[j] </span>
00325 <span class="comment">              &lt;&lt; std::endl; */</span>
00326 
00327         <a class="code" href="classSPRSearch.html#b3">sprCopy</a>(<a class="code" href="classSPRSearch.html#p10">_treeBuf2</a>, <a class="code" href="classSPRSearch.html#p8">_sprNeighbour</a>, outSub, <a class="code" href="classSPRSearch.html#p16">_sprTable2</a>[outSub]._pos[j], 
00328                 <a class="code" href="classSPRSearch.html#p12">_btable2</a>, <a class="code" href="classSPRSearch.html#p14">_ftable2</a>);
00329         <span class="keywordflow">if</span> (<a class="code" href="classSPRSearch.html#b4">updateCache</a>(<a class="code" href="classSPRSearch.html#p8">_sprNeighbour</a>))
00330           <span class="keywordflow">return</span> <span class="keyword">true</span>;
00331         ++<a class="code" href="classSPRSearch.html#o1">_sprCount</a>;
00332       }
00333 <span class="comment">//      std::cout &lt;&lt; std::endl;</span>
00334     }
00335   }
00336 
00337 <span class="preprocessor">#ifndef REKERNELIZE</span>
00338 <span class="preprocessor"></span>  assert(<a class="code" href="classSPRSearch.html#o1">_sprCount</a> == 
00339          ((2 * (<a class="code" href="classSPRSearch.html#p6">_kern</a>.numLeaves() - 3)) * 
00340          (2 * <a class="code" href="classSPRSearch.html#p6">_kern</a>.numLeaves() - 7)) - 
00341          (2 * <a class="code" href="classSPRSearch.html#p6">_kern</a>.numLeaves() - 6));
00342 <span class="preprocessor">#endif</span>
00343 <span class="preprocessor"></span>
00344   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00345 }
00346 
00358 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00359"></a><a class="code" href="classSPRSearch.html#b2">00359</a> <span class="keywordtype">void</span> <a class="code" href="classSPRSearch.html#b2">SPRSearch&lt;T&gt;::swapCopy</a>(<span class="keyword">const</span> <a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>&amp; src, <a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>&amp; dest, 
00360                             <span class="keywordtype">int</span> sub1[2], <span class="keywordtype">int</span> sub2[2])
00361 {
00362   <span class="keywordtype">int</span> i, j, k;
00363 
00364   <span class="keywordflow">for</span> (i = 0, j = 0; i &lt; src.size(); ++i)
00365   {
00366     <span class="keywordflow">if</span> (i == sub1[0])
00367     {
00368       <span class="keywordflow">for</span> (k = sub2[0]; k &lt;= sub2[1]; ++k)
00369       {
00370         dest[j++] = src[k];
00371       } 
00372       i = sub1[1];
00373     }
00374     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == sub2[0])
00375     {
00376       <span class="keywordflow">for</span> (k = sub1[0]; k &lt;= sub1[1]; ++k)
00377       {
00378         dest[j++] = src[k];
00379       }
00380       i = sub2[1];
00381     }
00382     <span class="keywordflow">else</span>
00383     {
00384       dest[j++] = src[i];
00385     }
00386   }
00387 }
00388 
00398 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00399"></a><a class="code" href="classSPRSearch.html#b3">00399</a> <span class="keywordtype">void</span> <a class="code" href="classSPRSearch.html#b3">SPRSearch&lt;T&gt;::sprCopy</a>(<span class="keyword">const</span> <a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>&amp; src, <a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>&amp; dest, <span class="keywordtype">int</span> srcPos,
00400                            <span class="keywordtype">int</span> destPos, <span class="keyword">const</span> <a class="code" href="classBracketTable.html">BracketTable&lt;T&gt;</a>&amp; btable,
00401                            <span class="keyword">const</span> <a class="code" href="classFlagTable.html">FlagTable&lt;T&gt;</a>&amp; ftable)
00402 {
00403   assert(src[srcPos].myType() != <a class="code" href="treetok_8h.html#a4a1">RB</a>);
00404   assert(src[destPos].myType() != <a class="code" href="treetok_8h.html#a4a1">RB</a>);
00405 
00406   <span class="comment">// DEBUG </span>
00407 <span class="comment">/*  for (int x = srcPos; x &lt;= btable[srcPos].pos[1]; ++x)</span>
00408 <span class="comment">    std::cout &lt;&lt; src[x];</span>
00409 <span class="comment">  std::cout &lt;&lt; " ---&gt;  ";</span>
00410 <span class="comment">  for (int y = destPos; y &lt;= btable[destPos].pos[1]; ++y)</span>
00411 <span class="comment">    std::cout &lt;&lt; src[y];</span>
00412 <span class="comment">  std::cout &lt;&lt; std::flush;</span>
00413 <span class="comment">*/</span>
00414   <span class="comment">// remove surrounding brackets</span>
00415   <span class="comment">// copy before destination</span>
00416   <span class="comment">// enclose dest and src in surrounding brackets</span>
00417   
00418   <span class="keywordtype">int</span> destNext = btable[destPos].pos[1] + 1; <span class="comment">// next position after destination</span>
00419   <span class="keywordtype">int</span> nestSrc[2];
00420   <span class="keywordtype">int</span> triPos[3];
00421   <span class="keywordtype">int</span> i, j, k;
00422   btable.getTriPos(triPos);
00423 
00424   <span class="comment">// if we a pruning and regrafting an entire trifurcation, we must</span>
00425   <span class="comment">// knock the brackets off of another trifurcation to keep 3 subtrees</span>
00426   <span class="keywordflow">if</span> (srcPos == triPos[0])
00427   {
00428     i = src[triPos[1]].myType() == <a class="code" href="treetok_8h.html#a4a0">LB</a> ? 1 : 2;
00429     nestSrc[0] = triPos[i];
00430     nestSrc[1] = btable[triPos[i]].pos[1];
00431   }
00432   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (srcPos == triPos[1])
00433   {
00434     i = src[triPos[2]].myType() == <a class="code" href="treetok_8h.html#a4a0">LB</a> ? 2 : 0;
00435     nestSrc[0] = triPos[i];
00436     nestSrc[1] = btable[triPos[i]].pos[1];
00437   }
00438   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (srcPos == triPos[2])
00439   {
00440     i = src[triPos[1]].myType() == <a class="code" href="treetok_8h.html#a4a0">LB</a> ? 1 : 0;
00441     nestSrc[0] = triPos[i];
00442     nestSrc[1] = btable[triPos[i]].pos[1];
00443   }
00444   <span class="comment">// otherwise, nesting brackets are the surrounding brackets</span>
00445   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (src[srcPos - 1].myType() == <a class="code" href="treetok_8h.html#a4a0">LB</a>)
00446   {
00447     nestSrc[0] = srcPos - 1;
00448     nestSrc[1] = btable[nestSrc[0]].pos[1];
00449   }
00450   <span class="keywordflow">else</span>
00451   {
00452     nestSrc[1] = btable[srcPos].pos[1] + 1;
00453     nestSrc[0] = btable[nestSrc[1]].pos[0];
00454   }
00455 
00456   <span class="comment">//DEBUG</span>
00457   assert(src[nestSrc[0]].myType() == <a class="code" href="treetok_8h.html#a4a0">LB</a>);
00458   assert(src[nestSrc[1]].myType() == <a class="code" href="treetok_8h.html#a4a1">RB</a>);
00459 <span class="preprocessor">#ifdef REKERNELIZE</span>
00460 <span class="preprocessor"></span><span class="comment">//  assert(ftable[nestSrc[0]] == false);</span>
00461 <span class="comment">//  assert(ftable[nestSrc[1]] == false);</span>
00462 <span class="preprocessor">#endif</span>
00463 <span class="preprocessor"></span>
00464   j = 0;
00465 
00466   <span class="keywordflow">for</span> (i = 0; i &lt; src.size(); ++i)
00467   {
00468     <span class="keywordflow">if</span> (i == destPos)
00469     {
00470       <span class="comment">// copy nesting left bracket</span>
00471       dest[j++] = src[nestSrc[0]];
00472       <span class="comment">// copy src subtree</span>
00473       <span class="keywordflow">for</span> (k = srcPos; k &lt;= btable[srcPos].pos[1]; ++k)
00474         dest[j++] = src[k];
00475       <span class="comment">// copy left bracket of dest tree</span>
00476       dest[j++] = src[i];
00477     }
00478     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == destNext)
00479     {
00480       <span class="comment">// copy nesting right bracket</span>
00481       dest[j++] = src[nestSrc[1]];
00482       <span class="comment">// copy i</span>
00483       dest[j++] = src[i];
00484     }
00485     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i != nestSrc[0] &amp;&amp; i != nestSrc[1] &amp;&amp; 
00486              (i &lt; srcPos || i &gt; btable[srcPos].pos[1]))
00487     {
00488       <span class="comment">// if i hasn't already been copied (ie not part of src or its</span>
00489       <span class="comment">// nesting brackets, then copy it</span>
00490       dest[j++] = src[i];
00491     }
00492   }
00493 
00494   <span class="comment">// DEBUG</span>
00495 <span class="comment">//  std::cout &lt;&lt; "  " &lt;&lt;  src &lt;&lt; " --&gt; " &lt;&lt; dest &lt;&lt; " (check)" &lt;&lt; std::endl;</span>
00496 }
00497 
00503 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00504"></a><a class="code" href="classSPRSearch.html#b4">00504</a> <span class="keywordtype">bool</span> <a class="code" href="classSPRSearch.html#b4">SPRSearch&lt;T&gt;::updateCache</a>(<a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>&amp; tree)
00505 {
00506 <span class="comment">// CANNOT USE _TREEBUF2</span>
00507   ++<a class="code" href="classSPRSearch.html#o2">_count</a>;
00508 
00509 <span class="comment">//  std::cout &lt;&lt; "ADDING TO CACHE " &lt;&lt; tree &lt;&lt; std::endl;</span>
00510   <a class="code" href="classSPRSearch.html#p5">_valid</a>.retrifurcate(tree, <a class="code" href="classSPRSearch.html#p9">_treeBuf1</a>, 0);
00511 <span class="comment">//  std::cout &lt;&lt; "RETRIED =       " &lt;&lt; _treeBuf1 &lt;&lt; std::endl;</span>
00512   <a class="code" href="classSPRSearch.html#p5">_valid</a>.reorder(<a class="code" href="classSPRSearch.html#p9">_treeBuf1</a>, tree);
00513 <span class="comment">//  std::cout &lt;&lt; "REORDERED =     " &lt;&lt; tree &lt;&lt; std::endl;</span>
00514 
00515   <span class="keyword">typename</span> <a class="code" href="classTreeCache.html">TreeCache&lt;T&gt;</a>::Result cres = <a class="code" href="classSPRSearch.html#p7">_cache</a>.update(tree, <a class="code" href="classSPRSearch.html#p19">_id</a>, <a class="code" href="classSPRSearch.html#p20">_iter</a>);
00516   <span class="keywordflow">if</span> (cres._hit == 1)
00517   {
00518     <span class="keywordflow">if</span> (cres._flag != <a class="code" href="classSPRSearch.html#p19">_id</a>)
00519       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00520     ++<a class="code" href="classSPRSearch.html#o3">_cacheHits</a>;
00521     <a class="code" href="classSPRSearch.html#p4">_man</a>.deleteLast();
00522     }
00523   <span class="keywordflow">else</span>
00524   {
00525 <span class="preprocessor">#ifdef REKERNELIZE</span>
00526 <span class="preprocessor"></span>    <a class="code" href="classSPRSearch.html#p1">_pool2</a>-&gt;<a class="code" href="classCVector.html#a9">push_back</a>(std::pair&lt;<a class="code" href="structUPTree.html">UPTree&lt;T&gt;</a>, T&gt;(tree, 0));
00527 <span class="preprocessor">#else</span>
00528 <span class="preprocessor"></span>    <a class="code" href="classSPRSearch.html#p1">_pool2</a>-&gt;<a class="code" href="classCVector.html#a9">push_back</a>(tree);
00529 <span class="preprocessor">#endif</span>
00530 <span class="preprocessor"></span>  }
00531   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00532 }
00533 
00534 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Oct 2 18:43:18 2006 for SPR by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
