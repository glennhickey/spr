\section{SPR Class List}
Here are the classes, structs, unions and interfaces with brief descriptions:\begin{CompactList}
\item\contentsline{section}{{\bf Bracket\-Table$<$ T $>$} (The brackettable stores some information from the tree strings for quick lookup: For each bracket, the offeset of its matching bracket is stored )}{\pageref{classBracketTable}}{}
\item\contentsline{section}{{\bf Chain\-Table$<$ T $>$} (Computes and stores the offsets of pendant leaves that are neighbours in a chain )}{\pageref{classChainTable}}{}
\item\contentsline{section}{{\bf Chain\-Table$<$ T $>$::NList$<$ T $>$} (The chain neighbours of a leaf )}{\pageref{structChainTable_1_1NList}}{}
\item\contentsline{section}{{\bf Cherry\-Table$<$ T $>$} (Stores the position of cherry neighbour of each leaf in the tree )}{\pageref{classCherryTable}}{}
\item\contentsline{section}{{\bf Crc32$<$ T $>$} }{\pageref{classCrc32}}{}
\item\contentsline{section}{{\bf CVector$<$ T $>$} (This is a c-style implementation of std::vector )}{\pageref{classCVector}}{}
\item\contentsline{section}{{\bf Extract\-Splits\-Forest} }{\pageref{classExtractSplitsForest}}{}
\item\contentsline{section}{{\bf Extract\-Subtree$<$ T, U $>$} }{\pageref{classExtractSubtree}}{}
\item\contentsline{section}{{\bf Flag\-Table$<$ T $>$} (This class keeps track of a boolean flag for each element of a tree string )}{\pageref{classFlagTable}}{}
\item\contentsline{section}{{\bf Flag\-Table$<$ T $>$::Flag$<$ T $>$} ({\bf Flag}{\rm (p.\,\pageref{structFlagTable_1_1Flag})} can specify if a given node is marked as frozen and/or marked for deletion )}{\pageref{structFlagTable_1_1Flag}}{}
\item\contentsline{section}{{\bf Flag\-Table$<$ T $>$::Neighbours$<$ T $>$} (Offset the next unflagged neighbour to the left and right of a position )}{\pageref{structFlagTable_1_1Neighbours}}{}
\item\contentsline{section}{{\bf Kernelizor$<$ T $>$} (Kernelizes pairs of trees by flagging common subtrees and chains in accordance with Rule 1 and Rule 2 )}{\pageref{classKernelizor}}{}
\item\contentsline{section}{{\bf Split$<$ T $>$} (A split corresponds to the bipartition of the leaf set induced by an internal edge )}{\pageref{classSplit}}{}
\item\contentsline{section}{{\bf Split\-PLess$<$ T $>$} ({\bf Split}{\rm (p.\,\pageref{classSplit})} pointer comparison )}{\pageref{structSplitPLess}}{}
\item\contentsline{section}{{\bf Split\-Table$<$ T $>$} (The split table can load all non-trivial splits of a tree and provide set-like operations with split tables of other trees in order to identify common splits )}{\pageref{classSplitTable}}{}
\item\contentsline{section}{{\bf Spr\-Helper$<$ T $>$} (Provides quick access to subtrees after a retrifurcation )}{\pageref{classSprHelper}}{}
\item\contentsline{section}{{\bf SPRSearch$<$ T $>$} (Breadth first search of SPR-neighbour graph )}{\pageref{classSPRSearch}}{}
\item\contentsline{section}{{\bf Spr\-Table$<$ T $>$} (Stores all possible regraft points for every subtree in a tree )}{\pageref{classSprTable}}{}
\item\contentsline{section}{{\bf Spr\-Table$<$ T $>$::NList$<$ T $>$} (List of valid regraft points )}{\pageref{structSprTable_1_1NList}}{}
\item\contentsline{section}{{\bf Subtree\-Rec$<$ T $>$} (Record corresponding to the information of one subtree )}{\pageref{structSubtreeRec}}{}
\item\contentsline{section}{{\bf Tree\-Cache$<$ T $>$} (Hash table with chaining that stores to references to trees )}{\pageref{classTreeCache}}{}
\item\contentsline{section}{{\bf Tree\-Cache$<$ T $>$::Node$<$ T $>$} (May want to templatize offset? maximum currently iteration hardcoded to 16 ==$>$ maximum distance is 32 os is potentially too small!! TODO: global max os value )}{\pageref{structTreeCache_1_1Node}}{}
\item\contentsline{section}{{\bf Tree\-Cache$<$ T $>$::Result$<$ T $>$} ({\bf Result}{\rm (p.\,\pageref{structTreeCache_1_1Result})} token for returning status of a call to {\bf update()}{\rm (p.\,\pageref{classTreeCache_a4})} )}{\pageref{structTreeCache_1_1Result}}{}
\item\contentsline{section}{{\bf Tree\-Distance$<$ T $>$} (Compute SPR-distance between two unrooted NEWICK trees )}{\pageref{classTreeDistance}}{}
\item\contentsline{section}{{\bf Tree\-Manager$<$ T $>$} (Stores a given number of trees in a contiguous chunk of memory )}{\pageref{classTreeManager}}{}
\item\contentsline{section}{{\bf Tree\-Tok$<$ T $>$} (Token used in the binary tree representation )}{\pageref{structTreeTok}}{}
\item\contentsline{section}{{\bf UPTree$<$ T $>$} (Binary-array representation of an Unrooted Phylogenetic Tree )}{\pageref{structUPTree}}{}
\item\contentsline{section}{{\bf Validator$<$ T $>$} (Validator class is responsible for verifying that a tree is properly formed )}{\pageref{classValidator}}{}
\end{CompactList}
